[
  {
    "id": "p1001",
    "questionTitle": "Assignment 1Uninformed",
    "problemStatementFull": "For this assignment, please implement
	a) Longest Common Subsequence Dynamic Programming approach with b and c arrays (LCS_DP_1(X,Y)) (Textbook Pg 394 ).
	b) LCS approach with b and c arrays LCS_DP_2(X,Y)) (Textbook Pg 394 with an additional constraint) The constraint on the LCS
	is that the characters chosen for the longest subsequence need to be in an ascending order only.
	Detailed requirements:
	• Write two programs for each of the algorithms named as LCS_DP_1.py and LCS_DP_2.py (or another extension if the code
	is in a language other than python). Code may be implemented in any programming language.
	• LCS_DP_1.py does the following:
	o reads a file LCS1.txt with two strings in each line and uses them as X and Y input variables for a function
	LCS_DP_1(X,Y))
	o LCS_DP_1(X,Y)) function
	▪ implements the dynamic programming version of LCS-LENGTH(X,Y) (Textbook Page 394)
	▪ populates arrays b and c
	▪ stores \, ^, < in array b instead of diagonal up arrow, up arrow, and left arrow and
	▪ produces corresponding b[i][j] c[i][j] side by side as shown below for all pairs of strings in LCS1.txt",
    "answerTitle": "Here's the solution for Longest Common Subsequence Dynamic Programming along with the report :",
    "tags": ["LCS", "Longest Common Subsequence Computer Science", " CSE 5311 "]
  },
  {
    "id": "p1002",
    "questionTitle": "Assignment 1 Uninformed",
    "problemStatementFull": "Assignment 1\n    Uninformed & Informed Search\n    Max possible score:\n    \n        4308: 100 Points [+40 Points EC]\n        5360: 100 Points\n    \n    Task 1 (This task will be used as part of the ABET assesment for CSE 4308 students)\n    Max: [4308: 100 Points, 5360: 100 Points]\n    Your task is to build an agent to solve a modifed version of the 8 puzzle problem (called the Expense 8 puzzle problem). The task is still to take a 3X3 grid on which 8 tiles have been placed, where you can only move one tile at a time to an adjacent location (as long as it is blank) and figure out the order in which to move the tiles to get it to a desired configuration. However now the number on the tile now also represents the cot of moving that tile (moving the tile marked 6 costs 6).\n    \n    Your program should be called expense_8_puzzle and the command line invocation should follow the following format:\n    \n    expense_8_puzzle.py <start-file> <goal-file> <method> <dump-flag>\n    \n        <start-file> and <goal-file> are required.\n        <method> can be\n            bfs - Breadth First Search\n            ucs - Uniform Cost Search\n            dfs - Depth First Search\n            dls - Depth Limited Search (Note: Depth Limit will be obtained as a Console Input) [Note: This part is EC for CSE 4308 students]\n            ids - Iterative Deepening Search [Note: This part is EC for CSE 4308 students]\n            greedy - Greedy Seach\n            a* - A* Search (Note: if no <method> is given, this should be the default option)\n        If <dump-flag> is given as true, search trace is dumped for analysis in trace-<date>-<time>.txt (Note: if <dump-flag> is not given, assume it is false)\n            search trace contains: fringe and closed set contents per loop of search(and per iteration for IDS), counts of nodes expanded and nodes\n    \n    Both start file and goal file need to follow the format as shown here:\n    \n        Sample Start file\n        Sample Goal file\n    \n    Your output needs to follow the format given in the example here:\n    \n    For:\n    \n    expense_8_puzzle.py start.txt goal.txt a* true\n    \n    The output should appear as follows:\n    \n    Nodes Popped: 97\n    Nodes Expanded: 64\n    Nodes Generated: 173\n    Max Fringe Size: 77\n    Solution Found at depth 12 with cost of 63.\n    Steps:\n    Move 7 Left\n    Move 5 Up\n    Move 8 Right\n    Move 7 Down\n    Move 5 Left\n    Move 6 Down\n    Move 3 Right\n    Move 2 Right\n    Move 1 Up\n    Move 4 Up\n    Move 7 Left\n    Move 8 Left\n    \n    In additon, the seach trace should have all the information contained in the file given here. (The format is not important, the information is)\n    \n    Note: for both greedy and A* search you need to come up with a acceptable heuristic (Hint: Consider a modified version of h2 as discussed in class)\n    \n    Note: Implementing DLS and IDS is required for CSE 5360 students but optional for CSE 4308 students (and carries upto 40 points EC)",
    "answerTitle": "Here's how you can build an agent to solve the Expense 8 Puzzle Problem:"
  },
  {
    "id": "p1003",
    "questionTitle": "Assignment Maximum repetitor factor",
    "problemStatementFull": "Let yi denote the concatenation of string y with itself i times. For example, (ab)3=ababab. We say that a string x ∈ Σ* has repetition factor r if x = yr for some string y ∈ Σ*and some r > 0. Let ρ(x) denote the largest r such that x has repetition factor r. Your task is listed below:
Design a quadratic-time algorithm that takes as input a pattern P[1..m], computes the value ρ(Pi ) for i = 1, 2, ..., m, and returns Pi and the underlying repeating substring. To test the correctness of your code,  Let P = abababa. Then ρ(P1) = 1: a; ρ(P2) = 1: ab; ρ(P3) = 1: aba; ρ(P4) = 2: ab; ρ(P5) = 1, ababa; ρ(P6) = 3: ab; ρ(P7) = 1: abababa. (Hint: Use the prefix function π(i).) (60 points)
Run the following experiment: generate m = 1,000 letters at random and form a pattern P in the order the letters are generated, where you may use a pseudo-random number generator to generate an integer between 1 and 26 for m times, with 1 representing a, 2 representing b, ..., 26 representing z. Compute the maximum repetitor ρ*(P) = max{ρ(Pi): i = 1, 2, ..., m}. Repeat this experiment for m times. What conclusion can you draw? (20 points)
Justify that, mathematically, your algorithm for item 1 runs in O(m2) time. (20 points)
Argue that, mathematically, if P is chosen uniformly and independently at random from the set of all binary strings of length m, the maximum repetitor factor ρ*(P) is expected to be a constant. (Optional: 20 bonus points)",
    "answerTitle": "Here's is the solution to above problem:"
  },
  {
    "id": "p1004",
    "questionTitle": "Assignment FFT",
    "problemStatementFull": "In addition to FFT (1-dimensional) convolution for achieving fast multiplication of two polynomials, 2-dimentional FFT (FFT2) has been widely used to compress images. The idea is this: Given an RGB image, first obtain a single value for each point (such as averaging RGB), apply FFT2 to compute its DFT on all the pixels in the image. For each pixel in the DFT, if its value is smaller than a threshold, then set it to zero. Finally, apply inverse DFT using IFFT2 to convert the result to an image. 
For an RGB image, instead of taking the average, we may seperate the image into 3 color channels: the red-color channel, the green-color channel, and the blue-color channel. Similar to the above algorithm, perform FFT2 on each channel separately, and for each point, if its value is below a threshold, then set it to 0. Then use inverse DFT (ifft) to convert it back to each channel. Finally, combine the channels to form the final compressed image.
Your task is to figure out what percentage of the point values to keep so that when it is inverted back to an image, you won't feel much degrading of the quality according to your judgement. Do an analysis on your experiments on a selection of several percentagaes. 
You may use the following image as input for testing your code",
    "answerTitle": "Here's how you can Solve this problem:"
  }